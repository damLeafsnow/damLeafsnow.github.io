###计算机体系与结构(6分)

####数据的表示(★★★★)

- #### 进制

  1. R进制转十进制：按权展开法
    
      > 二进制 10100.01=1x2<sup>4</sup>+1x2<sup>2</sup>+1x2<sup>-2</sup>

      > 七进制     604.01=6x7<sup>2</sup>+4x7<sup>0</sup>+1x7<sup>-2</sup>
      
  2. 十进制转R进制：短除法

      > 94 -> 二进制
      >
      > 2 | 94  余0
      >
      > 2 | 47      1
      >
      > 2 | 23      1
      >
      > 2 | 11      1
      >
      > 2 | 5        1
      >
      > 2 | 2        0
      >
      > 1
      >
      > 得到结果1011110

  3. 二进制转八进制：从右往左三位分割转换

    > 10 001 110
    >
    >  2	1	6

  4. 二进制转十六进制：从右往左四位分割转换

      > 1000 1110
      >
      > ​	8		E

- #### 编码-整数
	
	1. 原码
	
	原码：转换为二进制，左位补0至一字节,最高位为符号位
	
	> 十进制1  -> 0000 0001
	>
	 > 十进制-1 -> 1000 0001
	 >
	 > 1-1->1+(-1)-> 1000 0010 (-2),源码不可直接计算
	
	2. 反码
	
	   反码：正数时反码=原码，负数时反码=符号位+其余位取反
	
	   > 0000 0001  -> 0000 0001
	   >
	   > 1000 0001  -> 1111 1110
	   >
	   > 1-1->1+(-1)-> 1111 1111 (-0),不完全正确
	
	3. 补码
	
	   补码：正数时补码=原码，负数时补码=反码+1
	
	   > 0000 0001  -> 0000 0001
	   >
	   > 1111 1110  -> 1111 1111
	   >
	   > 1-1->1+(-1)-> 0000 0000 (0)，正确结果
	
	4. 移码
	
	   移码：用于浮点运算中的接码，移码=补码符号位取反
	
	   > 0000 0001  -> 1000 0001
	   >
	   > 1111 1111  -> 0111 1111
	   >
	   > 1-1->1+(-1)-> 1000 0000 (0)，移码中符号位意义相反
	
	5. 表示范围
	
	   |      |                  整数                  |     一字节(n=8)      |
	   | ---- | :------------------------------------: | :------------------: |
	   | 原码 | -(2<sup>n-1</sup>-1)~2<sup>n-1</sup>-1 |       -127~127       |
	   | 反码 | -(2<sup>n-1</sup>-1)~2<sup>n-1</sup>-1 |       -127~127       |
	   | 补码 |   -2<sup>n-1</sup>~2<sup>n-1</sup>-1   | -128~127(编码中无-0) |
	
	
	
- #### 编码-浮点数

   浮点数表示
   
   N = M*R<sup>e</sup>  , 其中M为尾数，e为指数，R为基数
   
   > 1000 -> 1.0x10<sup>3</sup>    119 -> 1.19x10<sup>2</sup> 
   
   计算过程：对阶(从低向高对)  ->  尾数计算  -> 结果格式化
   
   > 1000 + 119  = 1.0x10<sup>3</sup> + 1.19x10<sup>2</sup> 
   >
   >  对阶	  = 1.0x10<sup>3</sup> + 0.119x10<sup>3</sup> 
   >
   > 尾数计算  = 1.119x10<sup>3</sup> 
   
   结果格式化：尾数必须为1-9的个位数



####运算器与控制器(★★★★)

![_config.yml](E:/programming/git/damLeafsnow.github.io/_posts/{{ site.baseurl }}/images/computer.png)

计算机：运算器 控制器 存储器 输入设备 输出设备

存储器：主存储器(内存) 辅助存储器

CPU:	运算器 控制器 寄存器组 内部总线

主机： CPU 主存储器

运算器： 

- 算术逻辑单元**ALU**(arithmetic and logic unit) :算数逻辑运算

- 累加寄存器**AC**:暂时存放ALU运算的结果信息

- 数据缓冲寄存器**DR**(Data Register):暂时存放由内存储器读出的一条指令或一个数据字。当向内存存入一条指令或一个数据字时，也暂时将它们存放在数据缓冲寄存器中。

  - 其作用为:

    (1)作为CPU和内存、外部设备之间信息传送的中转站；
    (2)补偿CPU和内存、外围设备之间在操作速度上的差别
    (3)在单累加器结构的运算器中，数据缓冲寄存器还可兼作为操作数寄存器。

- [*]状态条件寄存器**PSW**(Program Status Word):保存由算术指令和逻辑指令运行或测试的结果建立的各种条件码内容,如运算结果进位标志（C），运算结果溢出标志（V），运算结果为零标志（Z），运算结果为负标志（N），中断标志（I），方向标志（D）和单步标识等。**(也可能属于控制器部分)**

控制器：

- 程序计数器**PC**(Program Counter)：存放下一条指令所在单元的地址。当执行一条指令时，首先需要根据PC中存放的指令地址，将指令由内存取到指令寄存器中，此过程称为**取指令**。
- 指令寄存器**IR**(Instruction Register)：临时放置从内存里面取得的程序指令的寄存器，用于存放当前从主存储器读出的正在执行的一条指令。
- 地址寄存器**AR**(Address Register):保存当前CPU所访问的内存单元的地址。由于在内存和CPU之间存在着操作速度上的差别，所以必须使用地址寄存器来保持地址信息，直到内存的读/写操作完成为止 
- 指令译码器**ID**(Instruction Decoder):计算机能且只能执行**指令**。指令由**操作码**和**地址码**组成。操作码表示要执行的操作性质，即执行什么操作，或做什么；地址码是操作码执行时的操作对象的地址。计算机执行一条指定的指令时，必须首先分析这条指令的操作码是什么，以决定操作的性质和方法，然后才能控制计算机其他各部件协同完成指令表达的功能。计算机执行一条指定的指令时，必须首先分析这条指令的操作码是什么，以决定操作的性质和方法，然后才能控制计算机其他各部件协同完成指令表达的功能。这个分析工作由指令译码器来完成。
- 时序部件:由主时钟源、节拍发生器和启停控制逻辑组成。其中的关键部件是节拍发生器。节拍发生器可以是一个环形计数器，也可以是一个计数译码电路。时钟电路包括一个晶体控制的振荡电路。晶体振荡器产生一个连续的正弦输出，正弦波转换为数字电路所需的方波。方波提供快速上升和下降的边界以触发事件。时钟频率越快，数据处理越快，处理频率来源于时钟频率。时钟是产生**周期信号**的基本方法，这些周期信号用于实现包括计算机在内的电子设备的**同步**。



####Flynn分类法(★★)

| 体系结构类型           | 结构                                       | 关键特性                                 | 代表                                 |
| ---------------------- | ------------------------------------------ | ---------------------------------------- | :----------------------------------- |
| 单指令流单数据流(SISD) | 控制部分：一个 处理器：一个 主存模块：一个 |                                          | 单处理器系统                         |
| 单指令流多数据流(SIMD) | 控制部分：一个 处理器：多个 主存模块：多个 | 各处理器异步执行同一指令                 | 并行处理机 阵列处理机 超级向量处理机 |
| 多指令流单数据流(MISD) | 控制部分：多个 处理器：一个 主存模块：多个 | 被证明**不可行**                         | 流水线计算机(文献记载)               |
| 多指令流多数据流(MIMD) | 控制部分：多个 处理器：多个 主存模块：多个 | 能实现**作业、任务、指令**等各级全面并行 | 多处理机系统 多计算机                |



####CISC与RISC(★★)—— 复杂/精简 指令集计算机

| 指令系统类型 | 指令                                                         | 寻址方式   | 实现方式                                             | 其它                       |
| ------------ | ------------------------------------------------------------ | ---------- | ---------------------------------------------------- | -------------------------- |
| CISC(复杂)   | 数量多，使用频率差别大，可变长格式                           | 支持多种   | 微程序控制技术(微码)                                 | 研制周期长                 |
| RISC(精简)   | 数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有Load/Store操作内存 | 支持方式少 | 增加了通用寄存器；硬布线逻辑控制为主；适合采用流水线 | 优化编译，有效支持高级语言 |

比较：指令数量，指令使用频率，寻址方式，寄存器，流水线支持，高级语言支持

> CISC:复杂，指令数量多，频率差别大，多寻址

> RISC:精简，指令数量少，操作寄存器，单周期，少寻址，多通用寄存器，流水线





#####指令的基本概念

1. 一条指令就是机器语言的一个语句，是一组有意义的二进制代码，基本格式为:

   > 操作码字段 | 地址码字段

2. 操作码部分指出了计算机要执行什么性质的操作，如加减法、存取数等。地址码字段需要包含各操作数的地址及操作结果的存放地址等。从**地址结构**的角度可以分为:

   > 三地址指令 | OP | A<sub>1</sub> | A<sub>2</sub> | A<sub>3</sub> |
   >
   > 二地址指令 | OP | A<sub>1</sub> | A<sub>2</sub> |
   >
   > 一地址指令 | OP | A<sub>1</sub> |
   >
   > 零地址指令 | OP |

#####寻址方式

1. 立即寻址方式

   操作数直接在指令中，速度快，灵活性差

   > IR| OP | 操作数 |

2. 直接寻址方式

   指令中存放操作数地址

   > IR| OP | 直接地址 |		主存储器
   >
   > ​										|	操作数  |

3. 间接寻址方式

   指令存放地址，地址对应操作数地址

   > IR| OP | 间接地址 |		主存储器

   > ​										|	操作数地址  |
   >
   > ​										|	操作数	|

4. 寄存器寻址方式

   寄存器存放操作数

   > IR| OP | R<sub>1</sub> |		R<sub>1</sub>

   > ​					|	操作数	|

5. 寄存器间接寻址方式

   寄存器内存放操作数地址

   > IR| OP | R<sub>1</sub> |		R<sub>1</sub>

   > ​					|	操作数地址  |
   >
   > ​						 存储器
   >
   > ​					|	操作数	|